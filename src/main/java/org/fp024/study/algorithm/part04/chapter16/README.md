##  Chapter 16 힙 소트

### 16.1 힙 소트의 원리
#### 16.1.1 탐색을 이용한 정렬
* 데이터를 한 줄로 세우는 것을 잊고, 다른 방향에서 접근해보자
* 탐색을 이용하여 정렬하는 것도 가능한대, 아래 개요를 확인해보자
* 탐색 트리를 이용한 정렬 알고리즘의 개요
    ```
    static void sort(int[] a) {
        int n = a.length;   // 배열의 요소 수
        
        // 탐색 트리를 생성
        SomeSearchTree x = new SomeSearchTree();
        
        // 배열의 모든 요소를 탐색 트리에 삽입한다.
        for (int i = 0; i < n; i++) {
            x.insert(a[i]);
        }
        
        // 키 값이 작은 것부터 순서대로 꺼내 배열에 넣는다.
        for (int i = 0; i < n; i++) {
            a[i] = x.deleteMin();
        }
    }
    ```
    1. insert()로 배열의 모든 요소를 탐색 트리에 등록
    2. deleteMin()으로 키값이 가장 작은 것 부터 큰 순서로 요소로 꺼내 배열로 되돌림
    * 복잡도
        * O(n log n)


#### 16.1.2 우선 순위 큐
* 정렬에 필요한 조작은 insert()와 deleteMin()동작 뿐이고 탐색트리 본래의 목적인 search() 를 사용하진 않기 때문에,  
  평균 트리와 같은 AVL트리나 B트리를 사용할 필요는 없다.  
  이때 우선 순위 큐(priority queue) 라는 추상 데이터 형을 사용하는 것이 유용하다.
  
* 우선 순위 큐
    * 각 요소에 `우선 순위`라는 값을 매겨 반드시 가장 큰 우선 순위를 가지고 있는 요소가 꺼내짐
    * 보통 큐와는 다르게 행렬에 들어간 순서는 꺼내는 순서에 아무런 영향도 가지지 않음.
    
    
#### 16.1.3 부분 순서 트리
* 부분 순서 트리(partial ordered tree)
    * 모든 노드에 대해 `부모 값은 자식의 값보다 크지 않다(즉, 부모는 자식보다 작거나 같다)` 란 조건을 만족하는 트리
    * 탐색 트리의 경우 자식들간의 대소관계가 정해져 있지만, 부분 순서 트리는 부자 간에만 제약이 있다.
        * 한 부모의 자식 가운데, 왼쪽 자식이 더 작아야한다는 등..
    * 처리 효율을 높이기 위해서 가능한 트리를 균형이 잡힌 형태를 유지함.
        * 루트에서 가장 떨어진 리프와 가장 가까운 리프의 경로 길이 차가 1이내가 되도록함.

* 부분 순서 트리에서의 최소 값 삭제 
    * `부모 값은 자식 값보다 크지 않다`라는 조건에 의해 트리에서의 최소 값은 루트가 된다. 
    * 루트 삭제후 부분 순서트리가 유지되도록 트리를 조작하는 것이 관건..

* 루트 삭제 후 트리 보정
    1. 루트 삭제
    2. 트리 최하단의 가장 오른쪽 요소를 루트 자리로 옮김
    3. 새로 루트가 된 요소를 기존 루트의 자식들 중 작은 자식과 바꿔감.
        * 자식들이 신규 루트보다 클 때까지 서브트리를 순회하며 반복적으로 수행.
    
* deleteMin()의 복잡도
    * 트리의 높이는 대략 log<sub>2</sub>n 정도가 되어 평균하면 log<sub>2</sub>n/2번 정도 교환이 이루어짐
    * `부모의 대소를 비교하여 필요하면 교환한다`란 처리를 일정시간 O(1)내에 할 수 있기 때문에  
    deleteMin()의 1회당 복잡도는 O(log n)이 됨
    
* 부분 순서트리에서 새로운 값 추가 및 트리 보정
    * 가장 왼쪽 부터 차례대로 추가
        * 리프가 꽉 찻다면 한층 더 내려 가장 왼쪽에 추가 (트리높이가 1증가)
    * 새로 추가된 값과 부모요소를 비교하여 부모가 작을 때까지 교환해나감.

* insert()의 복잡도
    * 트리의 높이는 log<sub>2</sub>n정도로 유지되기 때문에 부자를 교환하는 횟수는 평균 log<sub>2</sub>/2번 정도가 됨
    * `부자의 대소를 비교하여 필요하면 교환한다`라는 처리는 일정시간 `O(n)`에 할 수 있기 때문에  
      insert()의 복잡도는 O(log n) 이 됨.
      
      
#### 16.1.4 힙
* 부분 순서 트리 구현시 연결리스트를 사용해야할 경우 자식에서 부모로 가는 링크도 필요하기 때문에 복잡함
* 힙(heap)으로 부분 순서 트리를 효율적으로 구현 가능.

* 자료구조나 알고리즘의 세계에서 힙이라는 용어가 두개의 전혀 다른 의미를 가지고 있는 것에 주의
    1. 부분순서를 구현하기 위한 자료구조로서의 힙
    2. 메모리 관리에 관한 용어로 임의의 타이밍에 할당, 해제할 수 있는 메모리로서의 힙
    
* 자료구조로서의 힙
    * 배열의 첨자를 교모하게 사용함으로서 이진 트리에서 대응하는 부모와 자식을 간단하게 찾을 수 있게 되어있음.
        * 힙을 이용한 부분 순서 트리의 표현
        ```
                      5
                   /     \
                  9       15
               /   \      /  \ 
             12     13   21  18
            /  \    /
          17   25  20    
        ```

| a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7] | a[8] | a[9] | a[10] | a[11] | a[12] | a[13] | a[14] | a[15] |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :---: | :---: | :---: | :---: | :---: | :---: |
|  5   |  9   |  15  |  12  | 13   |  21  |  18  |  17  |  25  |  20   |  ---  |  ---  |  ---  |  ---  |  ---  |

* (참고) 위의 표가 IntelliJ의 마크다운 뷰어에서는 정상노출되지 않으나, github 페이지나 Typora 에서는 정상 노출된다.

* 노드 a[i]의 자식 => a[2*i]와 a[2*i+1] 
* 노드 a[i]의 부모 => a[i/2] (소수점 이하는 버림)

* `부분 순서 트리에서는 루트에서 리프까지의 경로 길이의 차가 1이내 이며`  
`가장 아래 단의 리프는 왼쪽부터 차례로 채운다`의 제약 때문에...  
  => 부분 순서 트리를 처음부터 n개의 요소(a[1]~a[n])만 사용하여 구현할 수 있게 됨


#### 16.1.5 Heap 클래스: 힙을 구현한다
* Heap 클래스 참고
* 처리를 쉽게 하기 위해 배열의 첨자를 1부터 시작해서 0번 인덱스는 사용하지 않는다.

#### 16.1.6 힙을 이용한 deleteMin 구현
* Heap.deleteMin() 참고

#### 16.1.7 힙을 이용한 insert 구현
* Heap.insert() 참고

### 16.2 힙 소트 프로그램
* Heap 클래스를 사용해서 Heap 정렬 구현
    * HeapSort0 클래스 참조
    * 문제점
        * 크기가 n인 힙을 필요로 한다는 점
    
* HeapSort0 의 개선
    * HeapSort 클래스 참조
    * Heap 정렬을 위한 n크기의 힙을 필요로 하지 않고, 정렬할 배열자체를 힙으로 다루고 정렬한다.
    * a[1]~a[n] 의 배열을 정렬, sort()에 전달되는 a에서 0번 인덱스는 정렬 범위에 포함되지 않는다.
    

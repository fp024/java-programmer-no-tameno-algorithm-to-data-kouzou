## Chapter 11 정렬이란?

### 11.1 정렬의 기본 개념
* 정렬(sorting)
    * 레코드(record)의 모임을 키 값의 대소 관계에 따라 다시 나열하는 조작
* 오름차순(ascending order) 정렬
    * 키가 작은 것 부터 큰순으로 나열
* 내림차순(descending order) 정렬
    * 키가 큰 것 부터 작은 순으로 나열


#### 11.1.1 내부 정렬과 외부 정렬
* 내부 정렬(internal sort)
    * 주 기억 장치(메모리)의 데이터를 정렬
    * 랜덤 엑세스(random access)가 가능함을 전제
        * 어떤 레코드라도 일정시간 내에 엑세스가 가능 
* 외부 정렬(external sort)
    * 외부 기억장치에 있는 데이터를 정렬
    * 시퀀셜 엑세스(sequential access)를 전제
        * 레코드의 처음부터 읽어들여 처리
    * 대표 알고리즘
        * 머지 소트(merge sort)
    
* 비교를 이용하는 정렬
    * 키의 대소를 비교하여 그 결과에 의해 레코드를 교환하는 알고리즘
    * 가장 빠른 알고리즘의 복잡도는 O(n log n)
        * 퀵소트, 힙소트   
  
* 비교를 이요하지 않는 정렬
    * 키의 특별한 성질을 이용한 알고리즘
    * 매우 빠르지만 특별한 경우에만 사용가능, 복잡도는 O(n)
        * 빈 소트, 분포수 세기 소트, 기수 소트

    
#### 11.1.2 비교를 이용하는 정렬과 비교를 이용하지 않는 정렬
* 비교를 이용하는 정렬
    * 각 레코드의 키의 대소 비교한뒤 위치를 바꾸어 정렬
    * 최소 O(n log n)의 복잡도가 필요하다는 것이 증명됨 
    * 퀵소트(quick sort), 힙소트(heap sort)

* 비교를 이용하지 않는 정렬
    * 키 값을 비교하지 않고 정렬
        * 예)키값을 어떤 특정범위의 정수로 한정함으로 키의 대소관계를 비교하지 않고 정렬가능
        * n 개의 레코드를 복잡도 O(n)에 정렬하는 것이 가능.
    * 빈 소트(bin sort), 분포수 세기 소트(distribute counting sort), 기수 소트(radix sort)
    * 비교를 이용하지 않는 정렬을 디지털 소트(digital sort)라고 부르기도 함.


### 11.2 정렬 알고리즘의 종류
* 단순 알고리즘
    * 종류
        * 버블 소트(bubble sort), 선택 소트(selection sort), 삽입 소트(insertion sort)
    * 단순하지만, 복잡도가 O(n<sup>2</sup>)로 대량의 레코드를 정렬하는데는 적절치 않음.

* 단순 알고리즘과 고속 알고리즘의 사이에 해당하는 알고리즘
    * 쉘 소트(shell sort)
    * 삽입 소트를 확장함, 복잡도는 O(n<sup>1.5</sup>) 정도 

* 고속 알고리즘
    * 퀵소트(quick sort), 힙소트(heap sort), 머지 소트(merge sort)
    * O(n long n) 의 복잡도, 퀵소트의 경우 최악의 경우 O(n<sup>2</sup>)가 될 수 있지만 회피방법이 있음

* 힙 소트
    * 힙(heap)이란 이진 트리를 배열로 구현한 자료구조
    * 데이터의 삽입, 탐색, 최소요소의 삭제를 O(n log n)에 할 수 있다면 최악의 경우라도 정렬 복잡도가 O(n log n) 이 될 수 있음.
    * 처리가 퀵소트에 비해 복잡해서 복잡도의 정수항이 크다.
    
* 머지 소트
    * 외부 정렬에 적합함.
    * 어떤 데이터에 대해서도 복잡도가 O(n log n) 이지만 정수항 부분이 약간 크다 


### 11.3 정렬의 복잡도
* 정렬 알고리즘의 주요 처리
    * 두 레코드의 키의 대소를 판정한다 (비교)
    * 만약 필요하다면 두 레코드의 위치를 바꾼다 (교환)

* 고속 알고리즘은 처리가 복잡해지는 경향이 있고, 단순 알고리즘에 비해 정수항이 커짐.
    * 일반적으로 n이 매우 작다면 단순알고리즘을 사용, 그 이상이면 쉘 소트나 퀵소트를 사용한다.
    * 저자님은 쉘소트도 단순하니 작더라도 쉘소트를 사용하라고 한다.

* 레코드가 너무 많아 주기억 장치에 들어가지 않는 경우는 머지소트 사용.


### 11.4 안정적인 정렬
* 정렬할 데이터에 같은 키를 가지는 레코드가 2개이상 있을 수 있는데, 
  이런 데이터를 정렬하더라도, 같은 키를 가지는 데이터의 정렬전 위치 관계도 유지하도록 하는 정렬 알고리즘을  
  안정적(stable)이라고 함
* 안정적인 정렬 예시
    * 정렬 전의 상태  
    \[ 7 | 9 | 5<sub>a</sub> | 4 | 8 | 5<sub>b</sub> | 2 ]
    * 정렬 후의 상태  
    \[ 2 | 4 | 5<sub>a</sub> | 5<sub>b</sub> | 7 | 8 | 9 ]

* 원래 키에 서브 키(sub key)로서 레코드의 위치까지 포함시키면 안정적이지 않은 알고리즘으로도 안정적인 정렬을 할 수 있음. 


### 11.5 java.util.Arrays 클래스의 sort 메서드
* sort 정적 메서드는 정수형 (byte, char, sort, int, long, float, double)  배열을 오름차순으로 정렬함.
* 1.8 부터는 parallelSort() 메서드도 추가되어있다.

## 퀵 소트

### 14.1 퀵 소트의 원리

#### 14.1.1 퀵 소트의 기본 개념
* n개의 요소 a[0], a[1], ..., a[n-1] 을 가지는 배열 a를 정렬할 때...  
  어떤 특정한 요소 하나를 고름 - x라고 하면    
  그 요소가 최종적으로 놓여질 위치 a[v]로 이동 시킨다.
* x를 추측(pivot)이라고 함.
    *  x보다 작은 요소는 a[v]의 왼쪽, 큰요소는 오른쪽으로 나누는 작업을 함.

* 3부분으로 나눠진 배열 a
    1. a[v]보다 작은 요소
        * a[0], a[1], ..., a[v-1]
    2. a[v]
    3. a[v]보다 큰요소
        * a[v+1], a[v+2], ...,a[n-1]

* 부분 배열이 단 하나만 이루어져있다면 정렬 완료된 상태

* 분할 정복 (divide and conquer, divide and rule)
    * 큰 문제를 여러 개의 작은 문제로 분할한 후 각개 격파하는 방법

##### 퀵소트 알고리즘 (의사코드)
```
// 배열에서 a[l] ~ a[r]을 정렬한다. 
static void quickSort(int[] a, int l, int r) {
    if (정렬할 요소가 하나 뿐이다.) {
       return; 
    }
    
    적당한 요소 a[v]를 주축으로 하여,
    a[v]보다 작은 요소를 a[l] ~ a[v-1] 에 모으고
    a[v]보다 큰 요소를 a[v+1] ~ a[r]에 모은다.
    
    quickSort(a, l, v-1); // 왼쪽 부분을 정렬한다.
    quickSort(a, v+1, r); // 왼쪽 부분을 정렬한다.
}
```


#### 14.1.2 분할 알고리즘
* 두개의 포인터를 사용하여 배열의 양쪽에서 중앙을 스캔해나감
    * 좌측부터 시작하는 포인터 i
    * 우측부터 시작하는 포인터 j
* 배열의 맨 끝을 추축으로 삼음
    * j는 배열의 끝에서 바로 직전

* 포인터 이동
    1. 주축 값 30보다 큰 요소를 발견할 때까지 포인터 i를 오른쪽으로 이동시킨다.
    2. 주축 값 30보다 작은 요소를 발견할 때까지 포인터 j를 왼쪽으로 이동시킨다.
    3. 포인터 i가 가리키는 요소의 포인터와 포인터 j가 가리키는 요소를 교환한다.
    4. 포인터 i와 j가 만날 때까지 1.~3. 을 반복
    5. 마지막으로 포인터 i가 가리키고 있는 요소(이것은 추축 값보다 크던지 같을 것임)를 오른쪽 끝요소와 교환한다.

* 안정성
    * 분할 처리에 의해 각 요소들의 분할하기전 위치관계가 사라지기 때문에 퀵소트는 안정적이지 않음.


### 14.2 퀵 소트 프로그램
* 재귀버전 퀵소트
    * QuickSortByRecursive 클래스 참고

### 14.3 퀵 소트의 복잡도
* 가장 빈번하게 수행 되는 부분
    * i, j를 이동시키는 루프
        * 비교 대상 한쪽이 pivot으로 고정되서 배열의 요소를 꺼내는 작업이 없어 비교적 유리한 부분이 있음.

* 퀵소트가 가장 빠르게 수행되는 경우
    * 분할한 결과 추축이 한 가운데 위치할 때.
* 느릴 경우
    * 추축의 위치가 계속 한쪽 끝으로만 위치할 경우
    * 복잡도 O(n<sup>2</sup>)가 되어버림  
    * 재귀가 n-1번 이루어짐.
        * 스택을 대량으로 소비 해버리게 됨.



### 14.4 개선된 퀵 소트

* 최악의 경우 극복 두가지
    1. 대증 요법 
        * 최악의 경우라도 어떻게든 처리는 계속할 수 있도록 하는 것
            * 스텍을 명시적으로 조작
            * 재귀 대신 루프 사용
    2. 두번째는 저자님이 과제로 주신다고 함.

* 비재귀 버전 퀵소트
    * QuickSortByNonRecursive 참고

* 비재귀 버전 퀵소트 (스택 오버 플로우 대책 적용됨)
    * QuickSortByNonRecursiveNew 참고
    

* 실제로 자주 사용되는 추축(pivot) 얻기
    * 3개의 데이터의 중간 값을 취하는 방법(median-of-three)
    * 배열의 왼쪽 끝/가운데/오른쪽 끝이 15, 21, 8 이라면 15를 추측으로 하는 기법
    * QuickSortPartition.medianOfTree() 메서드에 실제로 구현하고  
      정렬된 배열로 확인시 수행시간차이가 엄청 많이 났음. (10만개의 정수 오름차순 정렬 배열을 퀵정렬 시도)
      * 중간값 알고리즘을 쓰지 않을 때...
        * 수행시간: 1.3650545 seconds
      * 중간값 알고리즘을 쓸때... (100배 이상의 성능 향상이 있음)
        * 수행시간: 0.0103953 seconds
      
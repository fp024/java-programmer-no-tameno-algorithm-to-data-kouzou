## 머지 소트

### 15.1 머지 소트의 원리

#### 15.1.1 머지 처리
* 복잡도 O(n log n)인 고속 정렬알고리즘
* 정렬계수가 퀵소트보다 큼
* 요소를 시퀸셜 액세스 하여 정렬하는 특징
    * 주로 연결 리스트나 외부 기억장치 상의 데이터를 정렬하는데 사용됨

* 머지(merge) 조작
    * 정렬이 끝난 2개의 데이터 열을 하나의 데이터 열로 모으는 조작

    * 머지 알고리즘
        * 입력: 머지할 2개의 열 a, b
        * 출력: 열 a, b 요소를 머지하여 얻어진 열 c
            ```
            static void merge() {
                열을 비운다
                
                while(열a가 비어있지 않다. && 열b가 비어있지 않다) {
                    if (열a의 처음요소 <= 열b의 처음요소) {
                        열 a의 처음 요소를 제거하여 열 c의 마지막에 추가한다.
                    } else {
                        열 b의 처음요소를 제거하여 열 c의 마지막에 추가한다.
                    } 
                }
          
                if (열 a가 비었다) {
                    열 b에 남아있는 요소를 개대로 순서대로 열 c의 마지막에 추가한다.
                } else {
                    열 a에 남아있는 요소를 개대로 순서대로 열 c의 마지막에 추가한다.                      
                }      
            }
            ```
        * 열 c의 마지막의 의미를...
            * 만들어질 배열의 전체의 마지막이 아니고,
              현시점 채워져있는 부분의 마지막으로 보면 될 것 같다.


#### 15.1.2 머지 소트 알고리즘
* 머지를 이용하여 정렬하는 과정
    1. 데이터 열을 정확히 이등분하여 부분 열 a와 b로 분할한다.
    2. 부분 열 a와 b를 각각 정렬한다.
        * 재귀적으로 적용 부분열이 길이가 1이 되었을 때 종료
    3. 정렬이 완료된 부분 열 a와 b를 머지한다.

* 퀵소트는 분할단계에서 중요처리가 이루어졌고, 재귀호출 종료후에는 아무런 처리를 할 필요는 없었지만 머지소트는 분할 정렬 이후 머지를 한다.
    * 퀵소트
        1. 정렬 처리
        2. 분할한 부분을 재귀적으로 처리
    * 머지 소트
        1. 분할한 부분을 재귀적으로 처리
        2. 정렬 처리

* 머지 소트 알고리즘
    * 입력: 열 a
    * 출력: 열 a를 정리한 것
        ```
        static void mergeSort()  {
            if (열 a는 단 하나의 요소만 가지고 있다.) {        --- 과정(1)
                return;
            }
            
            열 a를 2개의 열 x, y로 분할한다.                  --- 과정(2)
            mergeSort를 재귀적으로 호출하여 열 x를 정렬한다.    --- 과정(3)
            mergeSort를 재귀적으로 호출하여 열 y를 정렬한다.    --- 과정(4)
      
            열 x와 y를 머지하여 그 결과를 열 a에 되돌린다.      --- 과정(5)
        }
        ```

### 15.2 배열을 이용한 머지 소트
* 배열 버전 머지 소트
    * Merge 하기위한 작업용 배열을 사용함    
    * MergeSortArray 참조

* 작업배열에 전반부 절반은 순차로 넣으시고, 후반부는 역순으로 두셨는데..
이게 센티넬을 활용하신 거라고 하셨는데... TODO: 이부분은 확인이 더 되야겠다. 


### 15.3 머지 소트의 성질
* n개의 요소를 분할 하는데 O(n) 만큼 걸림, 분할은 log<sub>2</sub> 번 실행
* n개의 요소를 머지하는데 O(n) 만큼 걸림, 머지는 log<sub>2</sub> 번 실행
    * 결론적으로 O(n log n)
* 퀵소트에 비해 결정적으로 불리한 점
    * 작업용 배열이 필요한 점
* 머지소트는 분할 할 때 요소의 이동이 발생하지 않음.
    * 머지할 때만 요소의 변경이 발생.  
* 값이 같을 때는 앞쪽 부분의 열이 처음 요소를 선택하도록 하면 안정적인 정렬을 할 수 있음.    

### 15.4 연결 리스트를 이용한 머지 소트
* 머지소트가 배열을 다루는데 적합하지 않은 이유
    1. 각 요소를 작업용 배열에 일단 복사한 후 원래 배열로 머지할 필요가 있다.  
    이 복사에 걸리는 시간을 무시할 수 없음.
    2. 작업용 영역으로 정렬할 데이터와 같은 크기의 영역이 필요.
    
* 연결리스트를 이용하면 요소 복사가 필요없이 링크를 바꾸기만 하면 다른열로 이동할 수 있어, 작업용 배열이 필요없음.

* 저자님께서는 배열버전보다 연결리스트 버전이 많이 수행시간이 많이 걸린다고 하셨는데...
    * 정렬대상이 10만개일 경우는 아래와 같았다. 
        * 배열 버전의 머지소트 (MergeSortArrayTest.testMergeSortArrayByLargeArray() 참고)
            * 수행시간: 7.2461178 seconds
        * 연결리스트를 사용한 수행시간 (MergeSortListTest.testMergeSortList() 참고)
            * 수행시간: 0.0285856 seconds
    * 배열 버전의 경우는 분할 마다 배열을 생성하고 복사하기 때문에 이런 차이가 벌어진 것 같다.
        * 정렬할 범위가 일정수 이하라면 저자님 말씀대로 배열버전이 빠를 것 같다.

* 연결리스트 정렬에는 퀵소트보다 머지소트가 유리함.

### 15.5 외부 정렬

#### 15.5.1 외부 기억 장치의 설징
* 내부 정렬 (internal sort)
    * 주기억 장치 상의 데이터를 정렬
* 외부 정렬 (external sort)
    * 외부 기억 장차 상의 데이터 정렬

* 외부 정렬시 고려할 점
    * 엑세스에 시간이 걸린다.
    * 입출력은 바이트 단위가 아니라 수백 바이트에서 수십 킬로바이트 크기의 블록 단위로 이루어진다.  

* 개선방법
    * CPU 처리시간을 다소 늘리더라도 입출력 횟수를 줄이는 것이 관건.
    

#### 15.5.2 머지 소트를 이용한 외부 정렬
* 기본 개념
    1. 데이터를 주 기억 장치에 넣을 수 있는 양 만큼 읽어들임
    2. 읽어 들인 데이터를 내부정렬
    3. 내부 정렬한 데이터를 외부 기억장치에 씀
        * 여기까지 주기억 장치에 들어갈 수 있는 크기의 정렬이 완료된 묶음들로 분할됨 (이묵음을 連(잇닿다,이어지다,연속할)연 이라함. run)
    4. 마지 알고리즘을 이용하여 이들 연을 하나의 열로 모음    
    
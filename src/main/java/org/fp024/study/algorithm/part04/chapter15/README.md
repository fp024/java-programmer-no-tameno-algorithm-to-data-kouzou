## 머지 소트

### 15.1 머지 소트의 원리

#### 15.1.1 머지 처리
* 복잡도 O(n log n)인 고속 정렬알고리즘
* 정렬계수가 퀵소트보다 큼
* 요소를 시퀸셜 액세스 하여 정렬하는 특징
    * 주로 연결 리스트나 외부 기억장치 상의 데이터를 정렬하는데 사용됨

* 머지(merge) 조작
    * 정렬이 끝난 2개의 데이터 열을 하나의 데이터 열로 모으는 조작

    * 머지 알고리즘
        * 입력: 머지할 2개의 열 a, b
        * 출력: 열 a, b 요소를 머지하여 얻어진 열 c
            ```
            static void merge() {
                열을 비운다
                
                while(열a가 비어있지 않다. && 열b가 비어있지 않다) {
                    if (열a의 처음요소 <= 열b의 처음요소) {
                        열 a의 처음 요소를 제거하여 열 c의 마지막에 추가한다.
                    } else {
                        열 b의 처음요소를 제거하여 열 c의 마지막에 추가한다.
                    } 
                }
          
                if (열 a가 비었다) {
                    열 b에 남아있는 요소를 개대로 순서대로 열 c의 마지막에 추가한다.
                } else {
                    열 a에 남아있는 요소를 개대로 순서대로 열 c의 마지막에 추가한다.                      
                }      
            }
            ```
        * 열 c의 마지막의 의미를...
            * 만들어질 배열의 전체의 마지막이 아니고,
              현시점 채워져있는 부분의 마지막으로 보면 될 것 같다.


#### 15.1.2 머지 소트 알고리즘
* 머지를 이용하여 정렬하는 과정
    1. 데이터 열을 정확히 이등분하여 부분 열 a와 b로 분할한다.
    2. 부분 열 a와 b를 각각 정렬한다.
        * 재귀적으로 적용 부분열이 길이가 1이 되었을 때 종료
    3. 정렬이 완료된 부분 열 a와 b를 머지한다.

* 퀵소트는 분할단계에서 중요처리가 이루어졌고, 재귀호출 종료후에는 아무런 처리를 할 필요는 없었지만 머지소트는 분할 정렬 이후 머지를 한다.
    * 퀵소트
        1. 정렬 처리
        2. 분할한 부분을 재귀적으로 처리
    * 머지 소트
        1. 분할한 부분을 재귀적으로 처리
        2. 정렬 처리

* 머지 소트 알고리즘
    * 입력: 열 a
    * 출력: 열 a를 정리한 것
        ```
        static void mergeSort()  {
            if (열 a는 단 하나의 요소만 가지고 있다.) {        --- 과정(1)
                return;
            }
            
            열 a를 2개의 열 x, y로 분할한다.                  --- 과정(2)
            mergeSort를 재귀적으로 호출하여 열 x를 정렬한다.    --- 과정(3)
            mergeSort를 재귀적으로 호출하여 열 y를 정렬한다.    --- 과정(4)
      
            열 x와 y를 머지하여 그 결과를 열 a에 되돌린다.      --- 과정(5)
        }
        ```

### 15.2 배열을 이용한 머지 소트
* 배열 버전 머지 소트
    * Merge 하기위한 작업용 배열을 사용함    
    * MergeSortArray 참조

* 작업배열에 전반부 절반은 순차로 넣으시고, 후반부는 역순으로 두셨는데..
이게 센티넬을 활용하신 거라고 하셨는데... TODO: 이부분은 확인이 더 되야겠다. 


### 15.3 머지 소트의 성질
* n개의 요소를 머지하는데 O(n) 만큼 걸림, 머지는 log<sub>2</sub>실행
    * O(n log n)
* 퀵소트에 비해 결정적으로 불리한 점
    * 작업용 배열이 필요한 점
* 머지소트는 분할 할 때 요소의 이동이 발생하지 않음.
    * 머지할 때만 요소의 변경이 발생.  
* 값이 같을 때는 앞쪽 부분의 열이 처음 요소를 선택하도록 하면 안정적인 정렬을 할 수 있음.    

### 15.4 연결 리스트를 이용한 머지 소트
* 머지소트가 배열을 다루는데 적합하지 않은 이유
    1. 각 요소를 작업용 배열에 일단 복사한 후 원래 배열로 머지할 필요가 있다.  
    이 복사에 걸리는 시간을 무시할 수 없음.
    2. 작업용 영역으로 정렬할 데이터와 같은 크기의 영역이 필요.
    

    



### 15.5 외부 정렬

#### 15.5.1 외부 기억 장치의 설징

#### 15.5.2 머지 소트를 이용한 외부 정렬




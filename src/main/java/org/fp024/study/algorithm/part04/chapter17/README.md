##  Chapter 17 비교를 이용하지 않는 정렬 

### 17.1 비교를 이용하지 않는 정렬 알고리즘
* 키의 대소 관계를 이용하는 한, 정렬 알고리즘의 복잡도는 O(n log n)보다 낮을 수 없다는 것이 이론상 증명되어있음.
* 키의 대소 관계를 이용하지 않는 알고리즘
    * 빈 소트 (bin sort)
    * 분포수세기 소트 (distribution counting sort)
    * 기수 소트 (radix sort)
    
* 위의 알고리즘은...
    * 실행시간 O(n)에 정렬할 수 있음
    * 큰 작업영역을 필요로함, 모두 O(n)의 공간 복잡도를 필요로함
    * 복잡도의 오더가 작다고는 하지만 실제로 사용시 O(n)과 O(n log n)의 차이가 그리 크진 않음.  
      실제 데이터를 이용하여 실험한후 알고리즘을 결정할 것.    

      
### 17.2 빈 소트

#### 17.2.1 빈 소트의 원리
* 가정
    * 정렬 대상이 되는 정수는 중복되지 않음
    
* 준비
    * 데이터가 취할 수 있는 모든 값에 대한 상자(bin)를 준비 
    * 하나 하나 그 값에 대응하는 빈에 넣어둠.
    * 값이 작은 빈에서 큰 빈순으로 내영물을 꺼내면 오름차순으로 정렬된 데이터를 얻을 수 있음.
    
* 다른 책에서 보았던, 배열의 인덱스를 이용해서 정렬하는 것과 비슷한 것 같다.

#### 17.2.2 빈 소트 프로그램
* BinSortData, BinSort 클래스 참고


#### 17.2.3 빈 소트의 성질
* 데이터 개수를 n, 준비된 빈의 개수를 m으로 할 때...
  * n개의 데이터를 빈에 나누는 데이는 O(n)
  * 데이터를 빈에서(오름차순으로) 꺼네기 위해서는 모든 빈을 순서대로 확인해야하여 O(m)만큼 걸림
  * O(m + n) 이됨.
  * 준비된 빈의 개수 m이 데이터의 개수 n에 비해 극단적으로 큰 경우를 제외하면 결국 빈소트에 걸리는 복잡도는 O(n)이라 볼 수 있음


* 키의 범위가 지나치게 넓을 경우에 빈소트를 사용하는 것은 적절하지 않음.

* 빈 소트의 약점
  1. 키의 중복을 허용하지 않는다.
  2. 키는 반드시 어떤 범위 내의 정수여야한다. (그 범위가 상당히 좁지 않으면 효율이 떨어짐)



### 17.3 분포수세기 소트

#### 17.3.1 분포수세기 소트의 원리

* 빈 소트: `키가 어떤 범위 내의 정수다` 라는 것을 전제로 한다.
  * 분포수 세기 소트(distribution counting sort)도 이 전제를 기반으로 한다.
  
* 원리
  * 모든 데이터를 스캔하여 키의 출현 빈도를 조사
    * 키의 출현 빈도를 알면, 키의 값을 기준으로 오름차순 정렬을 했을 때 키가 몇 번째 위치가 될지 알 수 있음.

##### 분포수세기 소트의 원리

* 대상이 되는 데이터 열은 7, 1, 4, 2, 7, 8, 2

| 키 k | 출현 회수 a | 누계 b |
| ---- | ----------- | ------ |
| 0    | 0           | 0      |
| 1    | 1           | 1      |
| 2    | 2           | 3      |
| 3    | 0           | 3      |
| 4    | 1           | 4      |
| 5    | 0           | 4      |
| 6    | 0           | 4      |
| 7    | 2           | 6      |
| 8    | 1           | 7      |
| 9    | 0           | 7      |
| 10   | 0           | 7      |

* a: 키 k를 가지는 요소의 개수 (출연 회수)
* b: 0이상 k이하의 키를 가지는 요소의 개수 (누계)
  
* 배열의 처음요소는 0
* 키 값이 k인 요소는 배열의 (b - a)번째부터 (b - 1)번째에 위치하게 됨.


#### 17.3.2 분포수세기 소트 프로그램
* 빈소트에서 사용했던 BinSortData 클래스는 그대로 사용
* DistributionCountingSort 클래스 참고
  * 분포수 세기 알고리즘은 주어진 배열 그 자체를 정렬하지 않고 정렬한 데이터를 다른 배열에 저장


#### 17.3.3 분포수세기 소트의 성질

* 분포수세기 소트의 수행 단계
  1. 카운터로 사용할 배열을 할당하고 초기화 
     * Java에서 배열 생성시 모든 요소를 0또는 null로 초기화하기 때문에 m개의 요소에 대해 O(m)
  2. 키의 개수를 센다
  3. 키의 누적 도수 분포를 구한다.
    * m-1번 실행 루프에 따라 O(m)
  4. 도수 분포에 따라 데이터를 배열 a에서 b로 복사
    * 2, 4는 n번 실행되어 O(n)   
  5. 배열 b의 데이터를 a로 복사한다.
    * O(n)

* 전체 복잡도는 O(m+n)가 되는데, 키의 종류 m이 데이터 개수 n에 비해 극단적으로 큰 경우를 제외하면 결국 O(n)이 된다.
* 키를 비교하는 알고리즘에 비해서는 빠르지만, 그 댓가로 큰 작업 영역을 필요로함.



### 기수 소트
* 빈 소트, 분포수 세기 소트 모두 키의 종류 m이 너무 많은 경우에는 사용할 수 없는 단점이 있음.
  * m에 비례한 크기의 작업용 배열이 필요한 문제점
  

#### 17.4.1 기수 소트의 원리

#### 17.4.2 기수 소트 프로그램

#### 17.4.3 기수 소트의 성질



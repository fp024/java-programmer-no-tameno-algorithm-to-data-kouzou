##  Chapter 17 비교를 이용하지 않는 정렬 

### 17.1 비교를 이용하지 않는 정렬 알고리즘
* 키의 대소 관계를 이용하는 한, 정렬 알고리즘의 복잡도는 O(n log n)보다 낮을 수 없다는 것이 이론상 증명되어있음.
* 키의 대소 관계를 이용하지 않는 알고리즘
    * 빈 소트 (bin sort)
    * 분포수세기 소트 (distribution counting sort)
    * 기수 소트 (radix sort)
    
* 위의 알고리즘은...
    * 실행시간 O(n)에 정렬할 수 있음
    * 큰 작업영역을 필요로함, 모두 O(n)의 공간 복잡도를 필요로함
    * 복잡도의 오더가 작다고는 하지만 실제로 사용시 O(n)과 O(n log n)의 차이가 그리 크진 않음.  
      실제 데이터를 이용하여 실험한후 알고리즘을 결정할 것.    

      
### 17.2 빈 소트

#### 17.2.1 빈 소트의 원리
* 가정
    * 정렬 대상이 되는 정수는 중복되지 않음
    
* 준비
    * 데이터가 취할 수 있는 모든 값에 대한 상자(bin)를 준비 
    * 하나 하나 그 값에 대응하는 빈에 넣어둠.
    * 값이 작은 빈에서 큰 빈순으로 내영물을 꺼내면 오름차순으로 정렬된 데이터를 얻을 수 있음.
    
* 다른 책에서 보았던, 배열의 인덱스를 이용해서 정렬하는 것과 비슷한 것 같다.

#### 17.2.2 빈 소트 프로그램
* BinSortData, BinSort 클래스 참고


#### 17.2.3 빈 소트의 성질
* 데이터 개수를 n, 준비된 빈의 개수를 m으로 할 때...
  * n개의 데이터를 빈에 나누는 데이는 O(n)
  * 데이터를 빈에서(오름차순으로) 꺼네기 위해서는 모든 빈을 순서대로 확인해야하여 O(m)만큼 걸림
  * O(m + n) 이됨.
  * 준비된 빈의 개수 m이 데이터의 개수 n에 비해 극단적으로 큰 경우를 제외하면 결국 빈소트에 걸리는 복잡도는 O(n)이라 볼 수 있음


* 키의 범위가 지나치게 넓을 경우에 빈소트를 사용하는 것은 적절하지 않음.

* 빈 소트의 약점
  1. 키의 중복을 허용하지 않는다.
  2. 키는 반드시 어떤 범위 내의 정수여야한다. (그 범위가 상당히 좁지 않으면 효율이 떨어짐)



### 분포수세기 소트

#### 17.3.1 분포수세기 소트의 원리

#### 17.3.2 분포수세기 소트 프로그램

#### 17.3.3 분포수세기 소트의 성질


### 기수 소트

#### 17.4.1 기수 소트의 원리

#### 17.4.2 기수 소트 프로그램

#### 17.4.3 기수 소트의 성질


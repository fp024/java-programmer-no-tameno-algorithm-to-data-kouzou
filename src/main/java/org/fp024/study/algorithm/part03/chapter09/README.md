## Chapter 09 이진 탐색트리 

### 9.1 이진 탐색 트리란?
* 트리
    가지로 나누어진 것을 표현하는데 적합한 자료 구조
* 이진 탐색 트리
    * 임의의 노드 x에 대해, 왼쪽 서브트리에 포함되는 요소는 노드 x보다 작고,  
    오른쪽 서브트리에 포함되는 요소는 노드 x보다 크다.
      


### 9.2 이진 탐색 트리의 조작
#### 9.2.1 이진 탐색 트리의 조작
루트요소가 x이고, k라는 값을 찾을 때..
1. `k == x`  
    루트요소 x와 일치하면 찾고자 하는 값이 루트에 존재 
2. `k > x`  
    k값을 가지는 요소가 존재할 경우 왼쪽 서브트리에 존재
3. `k < x`  
   k값을 가지는 요소가 존재할 경우 오른쪽 서브트리에 존재

* 자식이 존재하지 않을 경우라면 k값은 존재하지 않기 때문에 처리를 종료
* 트리가 이진 탐색트리의 성질을 만족한다면, 그 트리가 어떤 모양을 하고 있더라도 탐색할 수 있음
* 이 때의 복잡도
    * `가지가 뻗어난 정도`에 따라 결정됨.
  
##### Node 클래스
* `BinarySearchTree.Node`의 `label`은 정렬시 비교를 위해 비교가능해야한다. (Comparable 구현체)
    
   
#### 9.2.2 이진 탐색 트리에 삽입
어떤 키를 검색 했을 때, `그 키를 가진 데이터는 그 서브트리의 위치에 놓여 있어야한 다는 것을 의미`

* 탐색의 복잡도
    * 비교해야만 하는 노드의 수로 표현, 그러므로 높이가 낮고 충분히 가지가 뻗어있는 이진 탐색 트리쪽이 바람직함.
    
##### BinarySearchTree 클래스
* 제네릭을 사용한 구현으로 바꿈.
    * 저자님은 인자자체를 Comparable 인터페이스로 받는다. (1.4 시절이라 어쩔수 없응)
* insert(), search()는 함수정의만 보고 생각대로 해봄.
* 노드의 내용을 찍는 toString()은 재귀적으로 작성 해봄.


#### 9.2.3 이진 탐색 트리에서 삭제
1. Leaf 노드일 때의 삭제
    * 단순하게 그 노드를 없애버리기만 하면 됨.
2. 삭제할 노드가 자식을 하나만 가지고 있는 경우
    * 삭제가 있던 장소에 그 자식을 가져옴
    * 자식이 부모를 대체함
3. **(중요) 삭제할 노드가 자식을 둘 가지고 있을 때.**    
    * 오른쪽 서브 트리에 포함되어있는 가장 작은 요소와 바꾼다.
    
4. 이진 트리에서 가장 작은 요소를 찾아내는 것
    * 왼쪽으로 계속 이동하여 왼쪽 자식이 없는 노드에 도달 했을 때, 가장 작은 노드가 됨  
      (최소요소가 자식을 2개가지는 경우는 없음)
        1. 자식이 없는 가장 작은 노드  
           -> 단순이 그 노드를 제거하면 됨.
        2. 자식이 있는 가장 작은 노드 
           이진 탐색 트리의 정의에 따라 오른쪽 자식만 있는 경우  
           -> 자식을 끌어올리면 됨

### 9.3 이진 탐색 트리의 성질
* 이진 탐색트리 조작의 복잡도는 탐색의 복잡도로 귀결됨.


* 완전 이진 트리 (complete binary tree)
    * 루트로 부터 리프로의 경로의 길이가 같은 트리
    
* 복잡도
    * 최선일 때 O(log n)
    * 최악 일 떄 O(n)
        * 한쪽방향으로만 길게 늘어져 있는 트리가 될때.
        * 오름차순 또는 역순으로 데이터를 입력할 때. 이런 트리를 쉽게 만들 수 있음.
    




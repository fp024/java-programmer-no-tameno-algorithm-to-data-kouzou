##  Chapter 18 문자열 탐색

### 18.1 문자열에 대한 탐색
* 3부의 탐색 장에서 트리와 해시 표를 이용한 탐색알고리즘은  
  일정한 형태를 띈 레코드의 집합에서 특정 필드의 값이 지정한 값과 같은 레코드를 찾아내는 것이 였음

* 레코드와 같이 명확한 구조를 가지지 않는 데이터도 존재함. => 문자열(String)

* 데이터를 탐색할 때..
    * 레코드 구조 데이터 => `이 키를 가진 레코드를 찾아라!`
    * 문자열 => `문자 abc가 이 순서대로 늘어서 있는 장소를 찾아라`

* 문자열 탐색: 확정 패턴을 찾는 조작
* 패턴 매칭: 불확정 패턴을 찾는 조작

### 18.2 주먹구구식 알고리즘
#### 18.2.1 주먹구구식 알고리즘의 원리
* 문자열의 앞부터 1문자씩 자리를 이동해가며 패턴 일치 여부를 검사
    * 주먹구구식 알고리즘 (brute-force algorithm)
* BruteForce 클래스 참고


#### 18.2.2 주먹구구식 알고리즘의 복잡도
* 스트링 한 문자와 패턴 한 문자의 비교를 몇번 하였는가?
* 텍스트의 길이 m, 패턴의 길이를 n이라 할 때.
    * 최악의 경우
        * 패턴을 텍스으와 조회해 볼 수 있는 위치가 모두 (n - m + 1) 곳 있음
        * 모든 위치에 대해 패턴의 길이와 같은 회수 만큼(m번) 문자 비교 처리를함.
        * m(n - m + 1)번 만큼 비교함
        * n(문자열의 길이)이 m(패턴)보다 훨씬 크기 때문에 n - m + 1을  n으로 볼 수 있어서 O(mn) 이 될 수 있음
    * 자연어나 프로그래밍 언어에서는 문자의 종류가 많기 때문에, 대부분 패턴의 앞쪽 몇 문자를 조사하면 되어  
    실질적으로는 O(n)이 된다.
      
      
### 18.3 발전된 알고리즘
* KMP 법
    * `최악의 경우에도 m + n에 비례한 회수만 문자를 비교하는 문제열 탐색 알고리즘이 존재한다`는 이론을 증명
    * O(n)의 복잡도
* BM 법
    * 최악의 경우 O(n)
    * 일반적인 경우 O(n/m)

* 실용성
    * KMP 법 보다 BM 법이 중요하다, KMP 법이 최악의 경우에도 O(n)이 된다고는 하나 처리가 복잡하여 정수계수가 커서 큰 효과를 거둘수 없는 점이 있음

### 18.4 Knuth-Morris-Pratt 알고리즘
#### 18.4.1 KMP 법의 원리
* 주먹구구 알고리즘의 문제점
    * 패턴이 일치하지 않았을 때 패턴을 한문자 만큼 움직여 다시 패턴의 처음부터 비교하여, 도중까지의 비교로 얻어진 정보를 버림
    
* KMP 법의 기본 개념
    * 도중까지의 비교 정보로 패턴의 움직일 분량을 결정
    * 패턴에 포함되어있는 각 문자에 대해 그 문자와 일치하지 않았을 때에 패턴을 얼마만큼 이동시키면 좋을 지를 조사하여 표로 만듦.
    * 탐색을 할 때 이 표를 기준으로 패턴을 움직여가는 것
    
* 저자님이 코드 구현을 따로 하시진 않았는데, 다른 책을 참조해보자


#### 18.4.2 KMP 법의 성질
* 최악의 경우라도 복잡도가 O(n)
    * 텍스트의 포인터가 절대 뒤로 돌아가지 않는 특징에 따름
    * `텍스트와 패턴을  한번 비교함으로써 텍스트를 가리키는 포인터는 반드시 한 칸 이상 진행하며, 뒤로 돌아가지는 않는다`라는 성질로 문자비교를 n번 이상하지 않는다.
        
* 이론상 KMP 법이 주먹구구식 방법 보다 뛰어나지만, 현실적으로는 주먹구구식 방법을 사용하더라도 실질적으로는 O(n)에 처리할 수 있기 때문에  
저자님은 KMP 방법이 특별히 뛰어나다고 보시지 않고 있다.

* KMP 법이 주먹구구식 법보다 유리할 경우가 있다면?
    * 파일에 저장되어있는 텍스트에서 특정 패턴을 찾을 때 경우
        * 주먹구구
            * 포인터가 뒤로 돌아갈 수 있어 텍스트를 버퍼링해야함.
        * KMP
            * 현재 처리중인 한문자만 기억해두면 되어 뒤로 돌아가는 것의 대비를 위한 버퍼링이 필요없음

* KMPSearch 클래스 참조
    * 저자님이 KMP 관련해선 따로 구현하지 않으셔셔, Algorithms 4th 의 KMP 클래스를 약간만 바꿔서 실행만 시켜보았다.


### 18.5 Boyer-Moore 알고리즘
#### 18.5.1 BM 법의 원리
* 패턴을 역방향으로 체크하는 것이 BM 법의 본질


#### 18.5.2 BM 법의 실제
* 역방향 부터 체크 하면서 일치하지 않는 인덱스 부터 패턴을 이동시켜서 다시 역방향 비교를 한다는 의미 같다
* `텍스트의 비교 위치를 x문자 만큼 이동시켜 패턴의 마지막부터 다시 비교한다.`

#### 18.5.3 BM 법 프로그램
* Boyer-Moore 클래스 참고
    * 일치하지 않는 문자에 따라 패턴을 움직일 양을 정함
        * 탐색 처리에 들어가기 전에 미리 처리하여 표에 저장해둬야함.

    
#### 18.5.4 BM 법의 성질
* 대부분의 경우 패턴는 m문자씩 이동하게 됨
* `문자의 종류가 충분히 많다`라는 조건으로 빠르다는 전제를 가짐
* 패턴을 이동하는 양을 기록한 표를 작성하는 사전처리가 필요함
    * Java의 문자열은 2byte 유니코드로 표현되기 때문에 이동할 양을 기록한 표는 요소의 개수가 2<sup>16</sup>(65536)인 배열이된다.
    * 초기화 오버헤드를 고려할 것
    
* 최악의 경우
    * 주먹구구 방법의 최악의 경우를 역으로 한 것, O(mn)
    * 텍스트: "aaaaaaaaaaaaaaaaa"
    * 패턴: "baa"


## Chapter 04 배열

### 4.1 리스트
* 요소를 순서대로 나열한 것 (sequence)
* n개의 요소를 한줄로 나열한 것 (n >= 0)
* 순서가 정해져 있음
* 리스트의 기본 조작 요구사항
    1. k번째 요소의 앞에 요소를 삽입
    2. k번째 요소를 삭제
    3. k번째 요소의 내용을 읽고 씀
    4. 특정 키를 가지는 요소를 탐색
    5. 여러 리스트를 하나로 모음 (merge 인가?)
    6. 어러 리스트를 여러 리스트로 분할
    7. 리스트의 복제를 만듬
    8. 리스트에 포함되어있는 요소의 개수를 구함.
    
* 여기서 말하는 리스트는 연결리스트는 아님, 저자님이 연결리스트는 5장에서 설명하신다함.



### 4.2 스택
* 삽입과 삭제가 리스트의 맨 처음에서만 이루어짐
    * Push-Down List, Last-In First Out(LIFO) 후입 선출
* 삽입 삭제가 일어나는 쪽 top, 그 반대쪽 끝을 bottom
* 스택에 요소삽입(스택에 쌓음): Push 
* 스택에 요소삭제(스택에서 꺼냄): Pop



### 4.3 큐
* 삽입이 한쪽 끝에서만 이루어지고, 삭제는 반대쪽 끝에서만 이루어지는 리스트
* 동작 용어  
    * 맨 처음(요소) => front
    * 맨 마지막(요소) => rear
    * 큐에 넣음 => enqueue
    * 큐에서 꺼냄 => dequeue



### 4.4 배열을 이용한 자료구조 구현

### 4.4.1 리스트 구현
* 저자님이 리스트를 표현하기 위해서 배열로 표현을 할 수 있을 것이라고 하셨는데,  
  삽입 삭제에 대해서 밀고, 당기기 조작의 복잡도 때문에 O(n), 적절하진 않다고 한다. 
  ( ArrayList 코드를 보면 배열 버퍼를 내부적으로 쓰긴 쓰던데... )
* 그런데 스택과 큐는 배열로도 효율적인 구현이 가능하다고 함  


### 4.4.2 스택 구현
* 스택에 데이터 쌓기
    * `x[n++] = data;`
* 스택에서 데이터 꺼내기
    * `data = x[--n];`
    
* 스택에서는 요소의 삽입과 삭제가 복잡도 O(1)만에 끝나서 일반적인 리스트의 0(n)에 비하면 효율적  
  (중간값을 즉지 접근하거나 삭제할 수 없어서 그런 것 아닌지?)
* MyStack 참조
  
### 4.4.3 스택 사용 예 - 역 폴란드 전자 계산기


### 4.4.4 큐 구현




##  Chapter 19 백 트래킹

### 19.1 백 트래킹이란?
* 목적지에 다다르는 길이 명확히 드러나지 않는 알고리즘
* 이것저것 시행착오를 거치지 않으면 해결할 수 없는 문제
* 단순히 시행착오를 해선 탐색 후보가 막대해져서 답을 얻을 수 없음.
* 후보의 수를 가능한 작게 줄여 효율적으로 탐색하기 위한 방법이 필요.
    * => 이러한 방법 중 백 트래킹이란(back tracking) 방법이 있음.

* 백 트래킹
    * `모든 패턴을 계통적으로(systemically) 탐색하여 해답을 구한다.`
    * 시행착오 과정에서 더 이상 진행해봐야 소용없다고 판단한 경우에는  
      다시 뒤로 물러나 다른 갈림길로 나아감으로써 가능한 불필요한 처리를 하지않도록 함.
    * 가능한 빨리 선택지의 수를 줄여 후보의 수를 제한하는 것이 중요.
    
    * 목적지의 다다르는 경로가 여러 개 존재할 경우, 문제의 설정에 따라 고려
        1. (어느쪽이든 좋으니) 목적지까지의 경로를 하나만 발견하면 된다.
        2. 모든 경로를 발견하고 싶다.
        3. 모든 경로 중 최적의 것 (예를 들면, 가장 짧은 것)을 찾고 싶다.
    

### 19.2 8 퀸 문제

#### 19.2.1 8 퀸 문제란?
* `8 X 8 체스판 위에 8개의 퀸을 서로 잡히지 않도록 배치한다` 
* 체스의 퀸은 `상`/`하`/`좌`/`우`/`대각선` 모두 원하는 만큼 이동할 수 있다.
* 해석적인 방법으로 풀 수 없고, 판에 실제로 말을 배치하여 확인해볼 수 밖에 없음.

#### 19.2.2 8 퀸 문제의 해법
* 첫번째 생각
    * 처음 놓을 때, 64곳, 그다음은 63, ... 64-8 곳까지 생각할 수 있음
    * 그러나 퀸은 각 행에 하나씩만 둘 수 있음.
* 두번째 생각
    * 같은 행에 하나씩 둘 수 있으므로 8^8 으로 생각할 수 있음.
    * 그런데 열에대해서도 생각해야함.
* 세번째 생각
    * 행/열을 고려하게 되면 8!(펙토리얼)
    * 대각선까지 고려를 하지 않긴했지만 문제 범위가 40,320가지로 현실적으로 줄어들었다.
    
#### 19.2.3 8 백 트래킹 구현
* 재귀 호출을 이용하여 백 트래킹 구현
* 8퀸 문제의 해법 (해답을 하나만 찾는다)
    ```
    // 메서드 tryQueen은 행 a이후의 퀸을 모두 놓을 수 있었다면
    // true를 반환하고, 실패했다면 false를 반환한다
    //   위치에 대해서는 ... 장소 (행, 열)
    boolean tryQueen(int a) {
        for ( 장소(a, 0), (a, 1) ..... (a, 7)에 대해 반복한다. ) {
            if (이 장소는 다른 퀸에 의해 잡히지 않는다.) {
                이 장소에 퀸을 놓는다.
            }
            
            if (a == 7) { // 모든 퀸이 놓여졌다
                return true;
            } else {
                if (tryQueen(a + 1)) {  // 행 a + 1 이후의 모든 퀸을 놓았다
                    return true;
                } else {
                    실패했기 때문에 퀸을 체스 판에서 제거한다.
                }
            }
        }
        // 결국, 행 a에서는 퀸을 놓을 수 있는 장소가 없었다.
        return false;
    }
    ```

#### 19.2.4 8 퀸 프로그램
* 8 x 8 체스판을 떠올려 보면 ...
    * 체스판의 표현
        * `boolean[][] board = new boolean[8][8];`
    * 퀸이 배치됨 
        * `board[i][j] == true;`
    * 빈자리
        * `board[i][j] == false;`
    * 그런데 다른 퀸에 의해 잡히는 관계를 설정하기 어려움    

* 잡히는 관계를 표현하는 자료구조를 도입
    * 각 행의 퀸이 몇번째 놓여져 있는지를 의미하는 배열 pos
        ```
            pos[0] = 1;
            pos[1] = 4;
            pos[2] = 6;
            pos[3] = 3;
            pos[4] = 0;
            pos[5] = 7;
            pos[6] = 5;
            pos[7] = 2;
        ```
    * 잡히는 관계 표현을 위한 3개 배열
        * col
            * 수직 방향으로 잡히는지의 여부
        * down
            * 오른쪽으로(오른쪽 하단 방향) 기울어진 대각선으로 잡히는지의 여부
        * up
            * 왼쪽으로(왼쪽 상단 방향) 기울어진 대각선으로 잡히는지의 여부
    * 배열의 값은 `FREE` 또는 `NOT_FREE` 를 가짐

    * 오른쪽으로 기울어진 대각선
        * a, b를 지나는 선의번호 (N 은 체스 판의 크기)
            * `a - b + (N - 1)`
        * down 배열을 참조하여 `down[a - b + (N - 1)]` 가 `FREE`면 위치 (a, b)의 오른쪽으로 기울어진 대각선 상에는 다른 퀸이 없다는 의미
        * (a, b) 에 퀸을 배치할 때 `NOT_FREE`로 표시해두기
            * `down[a - b + (N - 1)] = NOT_FREE;`      

    * 왼쪽으로 기울어진 대각선
        * a, b를 지나는 선의 번호
            * `a + b`
    
* NQueen 클래스 참고
    * 처음 답안을 표시

    
#### 19.2.5 모든 답을 구한다.
* 8 퀸 문제의 모든 해법 (모든 답을 찾는다)
    ```
    void tryQueenAll(int a) {
        for ( 장소(a, 0), (a, 1) ...... (a, 7)에 대해 반복한다. ) {
            if (이 장소는 다른 퀸에의해 잡히지 않는다.) {
                
                이 장소에 퀸을 놓는다.
              
                if (a == 7) { // 모든 퀸이 놓여졌다.
                    체스 판을 표시한다.
                } else {
                    tryQueenAll(a + 1);
                }
                
                퀸을 체스 판에서 제거한다.
            }    
        }
    }    
    ```

* NQueen 클래스의 tryQueenAll() 메서드 참고
* 모든 퀸을 배치하는 것에 성공하였을 때, 체스판을 표시한 후 (StringBuilder 에 넣는 것으로 바꿈)  
  마지막에 놓여진 퀸을 제거하고 다음 위치로 시도해 보는 점이 다르다.
* 해결이 안되면 바로 앞 재귀 호출 상태로 돌아가면서 다음번 시작
    * 디버깅 로그를 따라가긴 했는데.. 호출이 엄청많다 ㅠㅠ

